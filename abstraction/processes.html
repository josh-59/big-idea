<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>The Process</title>
<link href="../style.css" rel="stylesheet" type="text/css">
</head>

<body>
	<header>
		<nav>
			<ul>
				<li> <a href="../index.html"> Home </a></li>
				<li> <a href="../abstraction/abstraction_home.html"> Abstraction </a></li>
				<li> <a href="../about.html"> About </a></li>
			</ul>
		</nav>

	</header>

	<br>

	<main>

		<h1> The Process </h1>
		<hr>
		<p>
			This paper introduces the process, a function without fixed points.
			All processes make change.
			A process is <i>a set of potential changes</i>, or,
			in the singular, a <i>change potential</i>.
		</p>

		<h2> Definition </h2>
		<p>
			Suppose <i>X</i> is a nonempty set.
			Then a function <i>p:X→X</i>&ensp;is a process if for all <i>x &#8712; X, p(x) &#8800; x</i>.
		</p>

		<p>
			We might also say that <i>p</i> is a process on <i>X</i>.
		</p>

		<h2> Example 1: Successor Function </h2>

		<p>
			Probably the simplest mathematical process we can consider is the successor function,
			<br><center><i>S:ℕ→ℕ by S(n) = n+1</i></center><br>
		</p>

		<p>
			In virtue of its mathematical definition, a process is a set
			(of potential changes).
			Of that set, we will typically be concerned with a single element
			of it.
			This we will call a <i>realized</i> process.
		</p>

		<p>
			Each realized process has three distict parts: Argument,
			Evaluation, and Result:
		</p>

		<h2 style="margin: 0"> Realized Process </h2>

		<img src="img/process_1.png"></img>

		<p>
			If <i>p</i> is a process, and <i>a</i> is an element in its domain,
			then <i>(a,p(a))</i> is a realized process, with argument <i>a</i>
			and result <i>p(a)</i>.
		</p>

		<h2> Example 2: Statements in High-Level Programming Languages </h2>
		<p>
			In a given high-level programming language, each statement that
			makes a change makes a clearly defined change.
			That is, there exists a well-defined state before the statement
			is executed, and there exists a well-defined state after
			the statement has executed.
			When these states are different, the statement forms a process.
		</p>

		<p>
			For instance, in C,
		</p>

		<div class="code">
			x = x + 1;
		</div>

		<p>
			Forms a process, while,
		</p>

		<div class="code">
			x *= 2;
		</div>

		<p>
			May or may not form a process (it does not when <code>x = 0</code>).  Also,
		</p>

		<div class="code">
			x *= 1;
		</div>

		<p>
			Certainly does not form a process.
		</p>

		<p>
			We define processes in this way to isolate change.
			We aren't interested in <i>the thing</i>, we're interested in
			what the thing <i>does</i>.
			If it does nothing, then it isn't a thing!
		</p>

		<h2> Metaprocess </h2>

		<p>
			Processes can be built up from constituent processes.
			The overarching process we will call a <i>metaprocess</i>.
			The above C snippets are regularly decomposed into assembly language
			(as by compilation).
			If <i>x</i> is a C statement which forms a process, and if <i>x</i>
			is compiled (into, say, x86), then some of the consituent assembly
			statements are processes.
		</p>

		<h2 style="margin: 0"> Realized Metaprocess </h2>

		<img src="img/metaprocess_with_4_constituents_blank.png" </img>

		<p>
			The idea of breaking down a desired change into smaller steps is, in my opinion,
			an enormously powerful concept.
			Each step becomes smaller and less complicated, while their
			composition is equivalent to a single large process.
			Key to this decomposing of processes is that the act of
			decomposition is not a process on the process in question&mdash;
			it manifests no change.
			Because of this, we are free to consider the resulting metaprocess
			alone, and ignore the constituent processes (and the means
			by which they are composed).
		</p>

		<p>
			Although the bulk of this development will be concerned with relations among processes,
			it will usually be sufficient to consider some arbitrary ``simple process''.
			For example, from the computer programmer's perspective, the machine instruction is the simplest process that can be considered; each machine instruction
			maps machine state to machine state.
			This is not the simplest process that can be considered; the layer underneath this is the realm of electrical engineers.
			Conversely, we can easily "elevate" our perspective by adopting some high-level language, like C or Ruby;
			in these cases, the simplest process is a single statement, and, while these statements also map machine state to machine state,
			we consider them to alter the abstract computational environment to which they belong.
		</p>

		</p>
			More often, a single statement in a programming language is considered to be the primitive process.
			In the opposite direction, an arbitrary process often belongs to a process greater than itself; in the case of the evaluation of a polynomial, it could be a test, an engineering problem, or other.
			We will call this the "metaprocess" of the given process.
		</p>

		<h2> Conclusion </h2>

		<p>
			A given <i>physical</i> process may be broken down indefinitely.
			In the first example, sawing a piece of plywood, we mentioned "pushing the workpiece through the saw."
			This might be broken down into a sequence of bio-mechanical processes.
			Those could be broken down into distinct chemical processes.
			Those could be broken down further still.
		</p>

		<p>
			Similarly, any given computer program can be broken down into constituent processes.
			In an imperative language, a program is composed of function calls.
			Each function call is composed of a sequence of statements.
			Each statement is a sequence of machine instructions.
			Further, each machine instruction can be broken down into logical state-changes,
			the concern of which is the electrical engineer.
			Further still, each interaction of these changes can be understood at an atomic level.
		</p>

		<p>
			Again, it is computer science that provides the key insight:
			It doesn't matter how the change occurs, as long as it is realizable.
			That is, we may ignore the implementing processes (details) as long as the desired process is attainable.
			For instance, the C programmer <i>does not</i> concern himself with how
			C code is translated into machine instruction; nor does he need to concern himself
			with how instructions are carried out at the machine level.
			The C programmer deals only with C statements; this simplification is the purpose of the C Programming Language.
		</p>

		<p>
			We will call these <i>viable pseudo-primitive processes</i>.
			For example, within computer programming, an "Instruction Set Architecture" is a key abstraction layer:
			Teams of electrical engineers produce a programmer-readable whitepaper describing the
			set of instructions that the CPU is capable of performing, and their effect on the machine's state.
			The CPU in question is guaranteed by its engineers to abide by the ISA, and as a
			consequence, the instructions of the ISA form a set of viable pseudo-primitive processes, relative to the
			CPU in question.
		</p>

		<p>
		  <center> <a href="#">Top </a> </center>
		</p>
		<footer>
			 Questions, comments, criticisms? <a href="mailto:josh.m.timmons@gmail.com" > Leave me feedback!</a>
		</footer>
	</main>

</body>
</html>
