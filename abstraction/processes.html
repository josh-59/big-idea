<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>The Process</title>
<link href="../style.css" rel="stylesheet" type="text/css">
</head>

<body>
	<header>
		<nav>
			<ul>
				<li> <a href="../index.html"> Home </a></li>
				<li> <a href="../abstraction/abstraction_home.html"> Abstraction </a></li>
				<li> <a href="../about.html"> About </a></li>
			</ul>
		</nav>

	</header>

	<br>

	<main>

		<h1> The Process </h1>
		<hr>
		<p>
			This paper introduces the process, a function without fixed points.
			All processes make change.
			A process is <i>a set of potential changes</i>, or,
			in the singular, a <i>change potential</i>.
		</p>

		<h2> Definition </h2>
		<p>
			Suppose <i>X</i> is a nonempty set.
			Then a function <i>p:X→X</i>&ensp;is a process if for all <i>x &#8712; X, p(x) &#8800; x</i>.
		</p>

		<p>
			We might also say that <i>p</i> is a process on <i>X</i>.
		</p>

		<h2> Example 1: Successor Function </h2>

		<p>
			Probably the simplest mathematical process we can consider is the successor function,
			<br><center><i>S:ℕ→ℕ by S(n) = n+1</i></center><br>
		</p>

		<p>
			In virtue of its mathematical definition, a process is a set
			(of potential changes).
			Of that set, we will typically be concerned with a single element
			of it.
			This we will call a <i>realized</i> process.
		</p>

		<p>
			Each realized process has three distict parts: Argument,
			Evaluation, and Result.
			I intend this to be understood as, "The process's <i>argument</i>,"
			"The process's <i>evaluation</i>,"
			and "The process's <i>result</i>," respectively.
		</p>

		<img src="img/process_1.png"></img>

		<p>
			Processes can be built up from constituent processes.
			Conversely, processes can often be decomposed into simpler processes.
			Thus far, our development of <i>abstraction</i> has been an inquiry into
			the process of observation.
		</p>

		<p>
			The idea of breaking down a desired change into smaller steps is, in my opinion,
			an enormously powerful concept.
			Each step becomes a smaller, less complicated task, yields some distinct change, and
			the change it yields becomes the basis for the next step&ndash; this last step being abstraction in the flesh.
			Examples exist in the fields of carpentry, mass production, assembly lines, mathematical proofs and computer science.
			Again, we will find that computer science provides the best examples.
		</p>

		<p>
			Although the bulk of this development will be concerned with relations among processes,
			it will usually be sufficient to consider some arbitrary ``simple process''.
			For example, from the computer programmer's perspective, the machine instruction is the simplest process that can be considered; each machine instruction
			maps machine state to machine state.
			This is not the simplest process that can be considered; the layer underneath this is the realm of electrical engineers.
			Conversely, we can easily "elevate" our perspective by adopting some high-level language, like C or Ruby;
			in these cases, the simplest process is a single statement, and, while these statements also map machine state to machine state,
			we consider them to alter the abstract computational environment to which they belong.
		</p>

		</p>
			More often, a single statement in a programming language is considered to be the primitive process.
			In the opposite direction, an arbitrary process often belongs to a process greater than itself; in the case of the evaluation of a polynomial, it could be a test, an engineering problem, or other.
			We will call this the "metaprocess" of the given process.
		</p>

		<h2> Conclusion </h2>

		<p>
			A given <i>physical</i> process may be broken down indefinitely.
			In the first example, sawing a piece of plywood, we mentioned "pushing the workpiece through the saw."
			This might be broken down into a sequence of bio-mechanical processes.
			Those could be broken down into distinct chemical processes.
			Those could be broken down further still.
		</p>

		<p>
			Similarly, any given computer program can be broken down into constituent processes.
			In an imperative language, a program is composed of function calls.
			Each function call is composed of a sequence of statements.
			Each statement is a sequence of machine instructions.
			Further, each machine instruction can be broken down into logical state-changes,
			the concern of which is the electrical engineer.
			Further still, each interaction of these changes can be understood at an atomic level.
		</p>

		<p>
			Again, it is computer science that provides the key insight:
			It doesn't matter how the change occurs, as long as it is realizable.
			That is, we may ignore the implementing processes (details) as long as the desired process is attainable.
			For instance, the C programmer <i>does not</i> concern himself with how
			C code is translated into machine instruction; nor does he need to concern himself
			with how instructions are carried out at the machine level.
			The C programmer deals only with C statements; this simplification is the purpose of the C Programming Language.
		</p>

		<p>
			We will call these <i>viable pseudo-primitive processes</i>.
			For example, within computer programming, an "Instruction Set Architecture" is a key abstraction layer:
			Teams of electrical engineers produce a programmer-readable whitepaper describing the
			set of instructions that the CPU is capable of performing, and their effect on the machine's state.
			The CPU in question is guaranteed by its engineers to abide by the ISA, and as a
			consequence, the instructions of the ISA form a set of viable pseudo-primitive processes, relative to the
			CPU in question.
		</p>

		<p>
		  <center> <a href="#">Top </a> </center>
		</p>
		<footer>
			 Questions, comments, criticisms? <a href="mailto:josh.m.timmons@gmail.com" > Leave me feedback!</a>
		</footer>
	</main>

</body>
</html>
