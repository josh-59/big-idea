<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>The Process</title>
<link href="../style.css" rel="stylesheet" type="text/css">
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>

<body>
	<header>
		<nav>
			<ul>
				<li> <a href="../"> Home </a></li>
				<li> <a href="./"> Processes </a></li>
				<li> <a href="../about.html"> About </a></li>
			</ul>
		</nav>

	</header>

	<br>

	<main>

		<h1> The Process </h1>
		<hr>
		<p>
			This paper introduces the process, a function without fixed points.
			All processes make change;
			a process is <i>a set of changes</i>.
		</p>

		<h2> Definition </h2>
		<p>
			Suppose $X$ is a nonempty set.
			Then a function $p:X→X$ is a process if for all $x &#8712; X, p(x) &#8800; x$.
		</p>

		<p>
			We might also say that $p$ is a process on $X$.
		</p>

		<h2> Example 1: Successor Function </h2>
		<p>
			Probably the simplest mathematical process we can consider is the successor function:
			$$S:ℕ→ℕ \text{ by } S(n) = n+1$$
		</p>

		<h2> Example 2: Nondivergent Process </h2>
		<p>
			A process need not be divergent. Let $p$ be a function on $\set{0, 1, 2}$ by
			$$
			p(x) = \begin{cases} 	\ 1 \text{ if } x = 0, \\
						 			\ 2 \text{ if } x = 1, \\
						 			\ 0 \text{ if } x = 2.
				   \end{cases}
			$$
			Then $p$ is a process with a range consisting of exactly
			three elements.
		</p>

		<p>
			More generally, any process acting on a finite set is
			nondivergent.
		</p>

		<h2 > Realized Process </h2>

		<p>
			In virtue of its mathematical definition, a process is a set
			(of changes).
			Of that set, we will typically be concerned with a single element
			of it.
			This we will call a <i>realized</i> process.
		</p>

		<p>
			Each realized process has three distict parts: Context,
			Evaluation, and Resolution:
		</p>

		<img src="img/process_1.png" title="Realized Process"></img>
		<h5 style="text-align: center; margin-top: -30px;"> The Realized Process </h5>

		<p>
			If $p$ is a process, and $a$ is an element in its domain,
			then $(a,p(a))$ is a realized process, with context $a$
			and resolution $p(a)$.
			We prefer <em>resolution</em> because the result of applying a process
			in a given context is always a valid argument for that process.
		</p>

		<p>
			We seek to isolate change, and the tool that we will use to do
            so is the process.
            Because the process is guaranteed to make a change, we seek
            to isolate the process; viewing the "argument" of a realized process
            as the process's context serves to reinforce the
            isolation of the process.
		</p>

		<h2> Example 3: Statements in High-Level Programming Languages </h2>
		<p>
			In a given high-level programming language, each statement that
			makes a change makes a clearly defined change.
			That is, there exists a well-defined state before the statement
			is executed, and there exists a well-defined state after
			the statement has executed.
			When these states are different, the statement forms a process.
		</p>

		<p>
			For instance, in C,
		</p>

		<div class="code">
			int x; <br>
			x = x + 1;
		</div>

		<p>
			forms a process, while,
		</p>

		<div class="code">
			x *= 2;
		</div>

		<p>
			may or may not form a process (it does not when <code>x = 0</code>, for instance).
            In addition,
		</p>

		<div class="code">
			x *= 1;
		</div>

		<p>
			and
		</p>

		<div class="code">
			x += 0;
		</div>

		<p>
			do not form processes.
		</p>

		<h2> Metaprocess </h2>

		<p>
			Processes can be built up from constituent processes.
			The overarching process we will call a <i>metaprocess</i>.
			The above C snippets are regularly decomposed into assembly language
			(by compilation).
            When they are not compiled, they exist as processes only in the
            abstract; that is, they are not realized.
        </p>

		<img src="img/metaprocess_with_4_constituents_blank.png" </img>
		<h5 style="text-align: center; margin-top: -30px;"> Realized Metaprocess </h5>

        <p>
			If <i>x</i> is a C statement which forms a process, and if <i>x</i>
			is compiled (into, say, x86), then some of the consituent assembly
			statements are processes; moreover, their net result includes(?)
            the statement given.
            Finally, each of the above statements which <em>are not</em>
            processes may be implemented by no constituent processes whatsoever.
		</p>

		<p>
			The idea of breaking down a desired change into smaller steps is
			an enormously powerful concept.
			Each step becomes smaller and less complicated, while their
			composition is equivalent to a single large process.
            In the case of the C programming language, it allows a
            "high level" statement to be implemented by a comparatively
            restricted instruction set architecture.
        </p>

        <p>
			Key to this decomposing of processes is that the act of
			decomposition is not a process on the process in question&mdash;
			it implements the desired statement without making a change to it.
			Because of this, we are free to consider the resulting metaprocess
			alone, and ignore the means
			by which they are composed;
            that is, we may abstract from the implementation while retaining
            pertinent information.
		</p>

        <h2> Fielding </h2>


		<p>
			<center> <a href="#">Top </a> </center>
		</p>

		<footer>
			 Questions, comments, criticisms? <a href="mailto:josh.m.timmons@gmail.com" > Leave me feedback!</a>
		</footer>
	</main>

</body>
</html>
