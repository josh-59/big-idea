<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>The Process</title>
<link href="../style.css" rel="stylesheet" type="text/css">
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>

<body>
	<header>
		<nav>
			<ul>
				<li> <a href="../"> Home </a></li>
				<li> <a href="./"> Processes </a></li>
				<li> <a href="../about.html"> About </a></li>
			</ul>
		</nav>

	</header>

	<br>

	<main>

		<h1> The Process </h1>
		<hr>
		<p>
			This paper introduces the process, a function without fixed points.
			All processes make change;
			a process is <i>a set of changes</i>.
		</p>

		<h2> Definition </h2>
		<p>
			Suppose $X$ is a nonempty set.
			Then a function $p:X→X$ is a process if for all $x &#8712; X, p(x) &#8800; x$.
		</p>

		<p>
			We might also say that $p$ is a process on $X$.
		</p>

		<h2> Example 1: Successor Function </h2>
		<p>
			Probably the simplest mathematical process we can consider is the successor function:
			$$S:ℕ→ℕ \text{ by } S(n) = n+1$$
		</p>

		<h2> Example 2: Nondivergent Process </h2>
		<p>
			A process need not be divergent. Let $p$ be a function on $\set{0, 1, 2}$ by
			$$
			p(x) = \begin{cases} 	\ 1 \text{ if } x = 0, \\
						 			\ 2 \text{ if } x = 1, \\
						 			\ 0 \text{ if } x = 2.
				   \end{cases}
			$$
			Then $p$ is a process with a range consisting of exactly
			three elements.
		</p>

		<p>
			More generally, any process acting on a finite set is
			nondivergent.
		</p>

		<h2 > Realized Process </h2>

		<p>
			In virtue of its mathematical definition, a process is a set
			(of changes).
			Of that set, we will typically be concerned with a single element
			of it.
			This we will call a <i>realized</i> process.
		</p>

		<p>
			Each realized process has three distict parts: Argument,
			Evaluation, and Resolution:
		</p>

		<img src="img/process_1.png" title="Realized Process"></img>
		<h5 style="text-align: center; margin-top: -30px;"> The Realized Process </h5>

		<p>
			If $p$ is a process, and $a$ is an element in its domain,
			then $(a,p(a))$ is a realized process, with argument $a$
			and resolution $p(a)$.
			We prefer <em>resolution</em> because the result of applying a process
			on a given argument is always a valid argument for that process.
		</p>

		<p>
			In the general case, we seek to describe change.
			However, our principle aim will be describing the process of
			abstraction, and, through this, the operation of the mind.
		</p>

		<h2> Example 3: Statements in High-Level Programming Languages </h2>
		<p>
			In a given high-level programming language, each statement that
			makes a change makes a clearly defined change.
			That is, there exists a well-defined state before the statement
			is executed, and there exists a well-defined state after
			the statement has executed.
			When these states are different, the statement forms a process.
		</p>

		<p>
			For instance, in C,
		</p>

		<div class="code">
			int x; <br>
			x = x + 1;
		</div>

		<p>
			Forms a process, while,
		</p>

		<div class="code">
			x *= 2;
		</div>

		<p>
			May or may not form a process (it does not when <code>x = 0</code>, for instance).  Also,
		</p>

		<div class="code">
			x *= 1;
		</div>

		<p>
			and
		</p>

		<div class="code">
			x += 0;
		</div>

		<p>
			do not form processes.
		</p>

		<h2> Metaprocess </h2>

		<p>
			Processes can be built up from constituent processes.
			The overarching process we will call a <i>metaprocess</i>.
			The above C snippets are regularly decomposed into assembly language
			(as by compilation).
			If <i>x</i> is a C statement which forms a process, and if <i>x</i>
			is compiled (into, say, x86), then some of the consituent assembly
			statements are processes.
		</p>

		<img src="img/metaprocess_with_4_constituents_blank.png" </img>
		<h5 style="text-align: center; margin-top: -30px;"> Realized Metaprocess </h5>


		<p>
			The idea of breaking down a desired change into smaller steps is, in my opinion,
			an enormously powerful concept.
			Each step becomes smaller and less complicated, while their
			composition is equivalent to a single large process.
			Key to this decomposing of processes is that the act of
			decomposition is not a process on the process in question&mdash;
			it manifests no change.
			Because of this, we are free to consider the resulting metaprocess
			alone, and ignore the constituent processes (and the means
			by which they are composed).
		</p>

		<p>
			Although the bulk of this development will be concerned with relations among processes,
			it will usually be sufficient to consider some arbitrary ``simple process''.
			For example, from the computer programmer's perspective, the machine instruction is the simplest process that can be considered; each machine instruction
			maps machine state to machine state.
			This is not the simplest process that can be considered; the layer underneath this is the realm of electrical engineers.
			Conversely, we can easily "elevate" our perspective by adopting some high-level language, like C or Ruby;
			in these cases, the simplest process is a single statement, and, while these statements also map machine state to machine state,
			we consider them to alter the abstract computational environment to which they belong.
		</p>

		</p>
			More often, a single statement in a programming language is considered to be the primitive process.
			In the opposite direction, an arbitrary process often belongs to a process greater than itself; in the case of the evaluation of a polynomial, it could be a test, an engineering problem, or other.
			We will call this the "metaprocess" of the given process.
		</p>

		<h2> Thoughts </h2>

		<p>
			A given <i>physical</i> process may be broken down indefinitely.
			For instance, any computer program written in an imperative language
			can be broken down into function calls, which would then be
			constituent processes of the program.
			Each function call is composed of a sequence of statements.
			Each statement is a sequence of machine instructions.
			Each machine instruction can be broken down into machine-state
			changes, the details of which concern the electrical engineer,
			and not the programmer.
			Each interaction yielding these changes can be understood
			at a deeper, physical level.
		</p>

		<p>
			Again, it is computer science that provides the key insight:
			It doesn't matter how the change occurs, as long as it is realizable.
			That is, we may ignore the implementing processes (details) as long as the desired process is attainable.
			For instance, the C programmer <i>does not</i> concern himself with how
			C code is translated into machine instruction; nor does he need to concern himself
			with how instructions are carried out at the machine level.
			The C programmer deals only with C statements; this simplification is the purpose of the C Programming Language.
		</p>

		<p>
			We will call these <i>viable pseudo-primitive processes</i>.
			For example, within computer programming, an "Instruction Set Architecture" is a key abstraction layer:
			Teams of electrical engineers produce a programmer-readable whitepaper describing the
			set of instructions that the CPU is capable of performing, and their effect on the machine's state.
			The CPU in question is guaranteed by its engineers to abide by the ISA, and as a
			consequence, the instructions of the ISA form a set of viable pseudo-primitive processes, relative to the
			CPU in question.
		</p>

		<p>
			<center> <a href="#">Top </a> </center>
		</p>

		<footer>
			 Questions, comments, criticisms? <a href="mailto:josh.m.timmons@gmail.com" > Leave me feedback!</a>
		</footer>
	</main>

</body>
</html>
