<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>The Process</title>
<link href="../style.css" rel="stylesheet" type="text/css">
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>

<body>
	<header>
		<nav>
			<ul>
				<li> <a href="../"> Home </a></li>
				<li> <a href="./"> Processes </a></li>
				<li> <a href="../about.html"> About </a></li>
			</ul>
		</nav>

	</header>

	<br>

	<main>

		<h1> The Process </h1>
		<hr>
		<p>
			This paper introduces the process, a function without fixed points.
			All processes make change;
			a process is <i>a set of changes</i>.
		</p>

		<h2> Definition </h2>
		<p>
			Suppose $X$ is a nonempty set.
			Then a function $p:X→X$ is a process if for all $x &#8712; X, p(x) &#8800; x$.
		</p>

		<p>
			We might also say that $p$ is a process on $X$.
		</p>

		<h2> Example 1: Successor Function </h2>
		<p>
			Probably the simplest mathematical process we can consider is the successor function:
			$$S:ℕ→ℕ \text{ by } S(n) = n+1$$
		</p>

		<h2> Example 2: Nondivergent Process </h2>
		<p>
			A process need not be divergent. Let $p$ be a function on $\set{0, 1, 2}$ by
			$$
			p(x) = \begin{cases} 	\ 1 \text{ if } x = 0, \\
						 			\ 2 \text{ if } x = 1, \\
						 			\ 0 \text{ if } x = 2.
				   \end{cases}
			$$
			Then $p$ is a process with a range consisting of exactly
			three elements.
		</p>

		<p>
			More generally, any process acting on a finite set is
			nondivergent.
		</p>

		<h2> Realized Process </h2>
		<p>
			In virtue of its mathematical definition, a process is a set.
			Of that set, we will typically be concerned with a single element
			of it.
			This we will call a <i>realized</i> process.
		</p>

		<p>
			Each realized process has two discernible elements,
            Argument and Result:
		</p>

		<img src="img/process_1.png" title="Realized Process"></img>
		<h5 style="text-align: center; margin-top: -30px;"> The Realized Process </h5>

		<p>
			If $p$ is a process, and $a$ is an element in its domain,
			then $(a,p(a))$ is a realized process, with argument $a$
			and result $p(a)$.
		</p>

		<p>
			We seek to isolate change, and the tool that we will use to do
            so is the process.
            Because the process is guaranteed to make a change,
            expressing change is now a matter of utilizing the process.
		</p>

		<h2> Example 3: Statements in High-Level Programming Languages </h2>
		<p>
			In a given high-level programming language, each statement that
			makes a change makes a clearly defined change.
			That is, there exists a well-defined state before the statement
			is executed, and there exists a well-defined state after
			the statement has executed.
			When these states are different, the statement forms a process.
		</p>

		<p>
			For instance, in C,
		</p>

		<div class="code">
			int x; <br>
			x = x + 1;
		</div>

		<p>
			forms a process, while,
		</p>

		<div class="code">
			x *= 2;
		</div>

		<p>
			may or may not form a process (it does not when <code>x = 0</code>, for instance).
            In addition,
		</p>

		<div class="code">
			x *= 1;
		</div>

		<p>
			and
		</p>

		<div class="code">
			x += 0;
		</div>

		<p>
			do not form processes.
		</p>

        <h2> Example 4:</h2>
        <h2> $p: \mathcal{P}(\{1\}) → \mathcal{P}(\{1\})$</h2>

        <p>
            Let $X = \mathcal{P}(\{1\})$, the power set of the set containing $1$.
            Then the only process on $X$ is,
            $$
            p(x) = \begin{cases} 	\ \{1\} \text{ if } x = \{\}, \\
                                    \ \{\} \ \ \text{ if } x = \{1\}. \\
                   \end{cases}
            $$
        </p>

        <p>
            We could have chosen "The set containing the empty set," or any
            other set with a single element.
        </p>


		<h2> Metaprocess </h2>

		<p>
			Processes can be built up from constituent processes.
            A <em>metaprocess</em> is a process which is an abstraction of one or more processes.
        </p>

        <p>
			For instance, the above C snippets are regularly decomposed,
            by compilation, into assembly language.
        </p>

		<img src="img/metaprocess_with_4_constituents_blank.png" </img>
		<h5 style="text-align: center; margin-top: -30px;"> Realized Metaprocess </h5>

        <p>
			If <i>x</i> is a C statement which forms a process, and if <i>x</i>
			is compiled (into, say, x86), then some of the constituent assembly
			statements are processes; moreover, their net result includes
            the result of the statement as it is given.
            Finally, each of the above statements which <em>are not</em>
            processes may be implemented by no constituent processes whatsoever.
		</p>

		<p>
			The act of breaking down a problem into smaller problems is
			an enormously powerful problem-solving tool: A different question gets asked,
			and a different question gets answered.
			Each step becomes smaller and less complicated, while their
			composition yields the desired result.
            In the case of the computer programming, it allows a
            "high level" statement to be implemented by a comparatively
            restricted instruction set architecture.
        </p>

        <h2> Metaprocess Example 1 </h2>
        <p>
            Consider the following C declaration:
        </p>

        <div class="code">
			int main() { <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int arr[1024];<br>
        </div>

        <p>
            At the end of this line, the C compiler is guaranteed to have
            allocated <code>1024*sizeof(int)</code> contiguous bytes on the stack.
            However, it does not guarantee that only <code>1024*sizeof(int)</code>
            bytes have been used (it is often the case that compilers
            use more memory than desired, in order to <a href="https://en.wikipedia.org/wiki/Data_structure_alignment">align elements in memory</a>).
            Another possible side-effect of this code is a change to the CPU's
            cache state; again, this does not change the requested change.
		</p>

        <p>
            Because the result of the assembly language code is guaranteed to
			include the allocation of <code>1024*sizeof(int)</code> bytes,
			we say that the sequence of assembly instructions <em>fields</em>
			the requested allocation.
			That is, there exists a nontrivial abstraction of the result of
			that sequence of instructions which includes the requested allocation.
			Because of this guarantee, we are free to ignore the implementing
			process(es), and treat the high-level statement (the metaprocess)
			as a process existing of its own accord.
        </p>

		<p>
			<center> <a href="#">Top </a> </center>
		</p>

		<footer>
			 Questions, comments, criticisms? <a href="mailto:josh.m.timmons@gmail.com" > Leave me feedback!</a>
		</footer>
	</main>

</body>
</html>
