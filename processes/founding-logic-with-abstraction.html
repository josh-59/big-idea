<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Founding Logic with Abstraction</title>
	<link href="../style.css" rel="stylesheet" type="text/css">
	<script>
	MathJax = {
		tex: {
			inlineMath: [['$', '$'], ['\\(', '\\)']]
		}
	};
	</script>
	<script type="text/javascript" id="MathJax-script" async
	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
	</script>
</head>

<body>
	<header>
		<nav>
			<ul>
				<li> <a href="../"> Home </a></li>
				<li> <a href="./"> Processes </a></li>
				<li> <a href="../about.html"> About </a></li>
			</ul>
		</nav>

	</header>

	<br>

	<main>
		<h1> Founding Logic with Abstraction </h1>
		<h2> Objects </h2>

		<p>
			We begin with objects, because they are fundamental to first-order logic.
			Intuitively, an object is a <em>thing</em> that we may talk about.
			In a formal development, we consider each object
			individually and explicitly.
		</p>

		<p>
			An object is a well-defined abstraction.
			This means that it is a simplification (intuitively, a subset of all observable facets) of something else, with the caveat that
			it is unique:  There is exactly one.
			Objects transcend language;
			they belong to the mind alone.
		</p>

		<p>
			It's worth giving a few examples of objects, before proceeding.
			For instance, a pen is an object, as is a book.
			In particular, we make no distinction between objects that can be "realized by"
			some physical entity and those that cannot.
			Therefore, the color <em>blue</em> is an object just as much as <em>a bottle</em> is an object,
			for it is a well-defined abstraction.
		</p>

		<p>
			This uniformity is justified by my interpretation of mathematics:
			The number <em>two</em> is an object&mdash; specifically, it's a particular quantity&mdash;
			and the number two is not "realized by" any physical entity.
			Rather, it is a simplification away from the observation of multiple physical entities.
			That is, the number two is an abstraction.
		</p>

		<h2> Symbols </h2>
		<p>
			In order to talk about an object, it is necessary to have a tangible reference
			to it.
			These tangible references will be called <em>symbols.</em>
			A symbol is a unique, identifiable abstraction from something written.
		</p>

		<p>
			Hence, $$x$$ is a symbol, as is $$max.$$
		</p>

		<p>
			When a symbol is defined to refer to an object,
			it is called a <em>name</em>, and we will say that the symbol <em>denotes</em> the object.
			The restriction is imposed that, if a symbol refers to an object,
			it refers to exactly one object.
			Formally, a <em>name</em> is a unique abstraction that refers to another unique abstraction.
			The situation can be likened to pointers in C:
		</p>

		<a href="img\pointer.png" title="Click for larger image"><img src="img/pointer.png"></a>

		<center><p style="font-size: small; width: 75%;"><em>
			In C, a </em>pointer<em> is a variable that hold the address of another
			variable.<sup><a href="#references">[1]</a></sup>
			Hence, if </em>p<em> is a pointer, and </em>x<em> and </em>y<em> are also variables,
			then we can arbitrarily assign to </em>p<em> the address of either </em>x<em> or </em>y<em> (or </em>p<em>), thereby giving ourselves a
			new, albeit indirect, handle to the memory implicitly referred to by </em>x<em> or </em>y<em> (or </em>p<em>).
		</em></p></center>

		<p>
			For example, the symbol $2$, as used above, denoted a quantity; it is therefore a
			name.
		</p>

		<p>
			<strong>Definition:</strong> A <em>variable</em> is a symbol that does not denote anything.
		</p>

		<p>
			For further reading on names, see &#167;3.2, "Terms," and &#167;6.1, "Names and Things Named,"
			of <em>Introduction to Logic.</em>
		</p>

		<h2> Language </h2>

		<p>
			In making a clear distinction between symbols, names and objects,
			we have begun to carve out the capability to generate languages for ourselves.
			Specifically, we can now assign any meaning we like to any symbol we like&mdash;
			that is, we can <em>define</em> symbols.
			Neither objects nor symbols belong to language; rather,
			interpretations of symbols (that is, definitions) belong to language.
		</p>

		<p>
			A new language, formally developed, is called an <em>object language.</em><sup>[2]</sup>
			The language used to describe an object language is called a <em>metalanguage.</em><sup>[2]</sup>
			Set theory is an example of an object language;
			English is an example of a metalanguage.
		</p>

		<p>
			A name that has a unique definition throughout the entirety of a language will
			be called an <em>individual constant</em>&mdash; "individual," because it
			denotes exactly one object; "constant," because it is invariant.
			In mathematics, these assignments are usually made clear through explicit definitions.
			The plain definition of <em>name</em> will be used in situations where
			the assignment is temporary, e.g., in situations where one would say,
			<em>Let x =...</em>
		</p>

		<p>
			Once an individual constant is defined, it may be assumed that the symbol denotes that object
			throughout the entirety of the language it is defined within; in other words, the uniqueness
			of an individual constant's definition is only guaranteed within its object language.
			The stipulation that a name refer to a single object represents a significant simplification.
			English, being a natural language, does not follow this rule.
			This is one of the reasons to develop formal languages:
			Multiple-meanings is an avenue of ambiguity.
		</p>

		<h2> Making Statements </h2>

		<p>
			Beyond symbols, object languages are also home to <em>predicates,</em>
			which allow us to make statements about objects.
			A predicate is a symbol that denotes a relation between two objects.
		</p>

		<p>
			The first predicate we will look at is the identity relation,
			denoted by the double-bar "equals sign."
			This predicate says that two names
			<em>denote the same</em> object:
		</p>

		$$
		a = b
		$$

		<p>
			The above says that $a$ refers to the same object as $b.$
		</p>

		<p>
			To give a concrete example, if we stipulate that the symbol $1$ denotes
			the set containing the empty set, then we arrive at the truism that,
		</p>

		$$
		1 = \{\{\}\}
		$$

		<p>
			I feel it prudent to reference the work of a more authoritative figure,
			when I claim that sameness of referent is the meaning of the equals-sign.
			So, on page 4 of <em>Axiomatic Set Theory</em>, Dr. Patrick Suppes has this to say:

			<div class="quote_text">
				"One [logical] principle used, concerning which there is some disagreement in practice
				among mathematicians, is that the double bar '=' is taken as the sign of identity.
				The formula '$x=y$' may be read '$x$ is the same as $y$',  '$x$ is identical with $y$'
				or '$x$ is equal to $y$'.  The last reading is permissible here only if it
				is understood that equality means sameness of identity (which is what it does mean in almost
				all ordinary mathematical contexts)."
			</div>
		</p>

		<p>
			A typical use of identity in mathematics is found in Walter Rudin's <em>Principles of Mathematical Analysis</em>.
			In the definition of an ordered set, we find:
		</p>

		<p> <strong> Definition </strong> Let $S$ be a set.  An <em>order</em> on $S$ is a relation, denoted by &lt;,
			with the following two properties:

			<ol>
				<li>
					If $x\in S$ and $y\in S$ then one and only one of the statements
					$$
					x < y, \hspace{2em} x = y, \hspace{2em} y < x
					$$
					is true.
				</li>
				<li>
					If $x, y, z \in S$, if $x < y$ and $y < z$, then $x < z$.
				</li>
			</ol>
		</p>

		<p>
			I interpret the first property as stating that, given any two elements of an ordered set, either one is larger than the
			other, or they are the same element;
			the second property stipulates transitivity.
			It should be noted that I will develop this logic only as long as it
			remains true to such mathematical statements.
		</p>

		<p>
			Both objects and names are mainstays of first-order languages;
			concurrently, <em>identity</em> is often included in first-order languages, and is
			often studied within first-order logic.
			However, note that because identity is a predicate, it does not <em>necessarily</em> belong
			to a given first-order language.
			As a consequence, it does not belong to first-order <em>logic</em>, per se,
			though it is usually developed there (for it is so common).
			For more on the subject of identity, see &#167;5.1, "Logic of Identity," of <em>Introduction to Logic.</em>
		</p>

		<p>
			This discussion has begun our study of predicates,
			and it is here that I begin to diverge from first-order logic.
			I define: A <em>predicate</em> is an individual constant that denotes a relation among objects,
			some of which may be fixed.
		</p>

		<p>
			A few examples of predicates:
			<ol>
				<li> $=$ </li>
				<li> $<$ </li>
				<li> <em>Is_Brother_Of</em></li>
			</ol>
		</p>

        <h2> Development, Theory </h2>

        <p>
            It is permissible to mix object and metalanguages, so long as doing so does not presuppose
            future material.
            A development uses the object language to further the object language.
        </p>

        <p>
            A development is a trace of a theory;
            is one of many possible traces of the same theory.
        </p>

        <p>
            A development is either founded on well-defined abstractions, or it is circular.
        </p>

        <p>
            One develops ideas in much the same way that one develops photographs.
        </p>




		<h2> Sentential / Truth-Functional Connectives </h2>

		<p>
			<em>Introduction to Logic</em>, Page 43:
			"We are not committed to developing a logic adequate to all the nuances of
			everyday language."

		<p>
			For example, the semantics of the implication are taught in most
			texts (including <em>Introduction to Logic</em>) not to depend upon
			any non-truth relation, so that a sentence like,
				$$
			\text{If the sky is blue, then } 2 + 2 = 4
				$$
			is considered a valid use of the implication connective.
			As proof, the above implication is considered <em>true</em>, by modern logicians.
		</p>

					<p>
						This is done for well-devised reasons:
						<ol>
							<li>Given a declarative sentence, we can always determine its truthity</li>
							<li>By defining implication in terms of truth-values, we can make its meaning explicit</li>
						</ol>

						Indirection (notes):
							https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering

							An example of poor indirection:
							Definition 16, Graph Theory
							"Are said to be"
						</p>

						<p>
							Another thing one can say about objects, which the developments of
							logic given above do not touch upon, is that one object may be contained in
							another object.
							Tentatively, we will define this as the <em>is</em> relation.
							We define:
							For any two objects $a$ and $b$, "$a$ <em>is</em> $b$" is true if and only
							if $b$ is a correct abstraction of $a.$
						</p>

						<p>
							This is used in natural language to make statements like, "That bottle is blue."
							The abstraction denoted by "bottle" contains the abstraction "blue,"
							and "blue" is a correct abstraction of the bottle;
							we might say things like, "Hand me that blue thing over there."
						</p>

						<h2> Implicit Definitions </h2>
						<p>
							In mathematics and all empirical sciences, it is customary to use
							explicit definitions wherever possible.
							This isn't always possible, and it isn't necessary, either.
							To define a symbol, we only require that it denote a unique abstraction.
							So, we can identity this abstraction indirectly, a technique often used in
							pure logic.
						</p>

						<p>
							For instance, the number $2$ is unambiguously identified by,
							"A natural number that is less than three and greater than one."
						</p>

						<h2>About</h2>

						<p>
							My other project, <a href="https://josh-59.github.io/Learning-Linux/">Learning Linux</a>,
							has been remarkably successful in teaching me about Linux.
							In addition, it's taught me to read works of all kinds, because the struggle in writing well
							about Linux has been in using language to express ideas, where the ideas are well-founded, and the language is variable.
							It seemed that a similar pattern was forming in the study of logic: That my own thoughts on logic
							exist, but are not sufficiently defined to be unambiguous, and therefore,
							progress in learning the subject has stalled.
						</p>

						<p>
							So, I endeavor to recapture the success of the Learning Linux project, in the study of logic.
							The two books I'm reading on logic are, <em>Language, Proof and Logic</em>, 2<sup>nd</sup> ed., by Dave Barker-Plumer,
							Jon Barwise & John Etchemendy; and
							<em>Introduction to Logic</em> by Patrick Suppes.
							I mention this because these, together, form the foundation of my studies about logic.
							<em>Language, Proof and Logic</em> is a contemporary work on the subject of logic; moreover,
							because it is the work of three authors, I feel that it represents well the subject as it
							is taught today.
							<em>Introduction to Logic</em> was written in 1957; although it is comparatively dated,
							Patrick Suppes is a remarkable author.
						</p>


						<h2> Indirection </h2>

						<p>
						    There are always two ways to approach a problem.
                            1) To add greater specificity to existing abstractions
                            2) Introduce a new layer of indirection
						</p>

						<h2> Other Kinds of Names </h2>

						<ul>
							<li>
								<strong>Definite Description:</strong>
								A description of an object which is sufficiently precise to function as a name.
								For example, the description, <em>"The set containing the empty set,"</em>
								is definite.
							</li>
							<li>
								<strong>Variable:</strong>
								A name that does not denote anything
							</li>
							<li>
								<strong>Term:</strong>
								An <em>individual constant,</em> a <em>variable,</em> or a <em>definite description.</em>
							</li>
							<li>
								<strong>Symbol:</strong>
								A term that is not a definite description.
							</li>
							<li>
								<strong>Referent:</strong>
								The object that a name denotes.
							</li>
						</ul>

        <h2> Notes </h2>
        <ul>
            <li> Contradiction is false</li>
            <li> Name as a very simple kind of relation </li>
            <li>



						<div id="#references">
							<ol>
								<li> Kernighan, B. and Ritchie, D., 1988.  <em>The C Programming Language.</em> Englewood Cliffs, N.J.: Prentice Hall. </li>
								<li> Suppes, Patrick C., 1960. <em>Axiomatic Set Theory.</em> New York, NY: Dover Publications, Inc..  Corrected and republished in 1972 by Dover Publications. </li>
							</ol>
						</div>


						<center> <a href="#">Top </a> </center>
					</p>

					<footer>
						Questions, comments, criticisms? <a href="mailto:josh.m.timmons@gmail.com" > Leave me feedback!</a>
					</footer>
				</main>

			</body>
			</html>
